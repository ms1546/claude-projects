//\n//  AnimationOptimizer.swift\n//  TrainAlert\n//\n//  Created by Claude on 2024/01/08.\n//\n\nimport SwiftUI\nimport Foundation\nimport OSLog\n\n/// Animation optimization utilities to maintain 60fps performance\nstruct AnimationOptimizer {\n    \n    // MARK: - Performance-Optimized Animations\n    \n    /// Fast spring animation for UI interactions\n    static let fastSpring = Animation.interpolatingSpring(\n        mass: 0.5,\n        stiffness: 300,\n        damping: 20,\n        initialVelocity: 0\n    )\n    \n    /// Smooth spring animation for transitions\n    static let smoothSpring = Animation.interpolatingSpring(\n        mass: 1.0,\n        stiffness: 200,\n        damping: 25,\n        initialVelocity: 0\n    )\n    \n    /// Gentle spring animation for subtle effects\n    static let gentleSpring = Animation.interpolatingSpring(\n        mass: 1.5,\n        stiffness: 150,\n        damping: 30,\n        initialVelocity: 0\n    )\n    \n    /// Quick easing for button taps\n    static let quickEase = Animation.easeOut(duration: 0.2)\n    \n    /// Standard easing for most transitions\n    static let standardEase = Animation.easeInOut(duration: 0.3)\n    \n    /// Slow easing for page transitions\n    static let slowEase = Animation.easeInOut(duration: 0.5)\n    \n    // MARK: - Optimized Animation Timing\n    \n    /// Animation durations optimized for 60fps\n    enum Duration {\n        static let instant: TimeInterval = 0.1\n        static let fast: TimeInterval = 0.2\n        static let standard: TimeInterval = 0.3\n        static let slow: TimeInterval = 0.5\n        static let verySlow: TimeInterval = 0.8\n    }\n    \n    // MARK: - Custom Animations\n    \n    /// Create a performance-optimized custom animation\n    /// - Parameters:\n    ///   - duration: Animation duration\n    ///   - curve: Animation curve type\n    /// - Returns: Optimized animation\n    static func optimizedAnimation(\n        duration: TimeInterval,\n        curve: AnimationCurve = .easeInOut\n    ) -> Animation {\n        switch curve {\n        case .linear:\n            return .linear(duration: duration)\n        case .easeIn:\n            return .easeIn(duration: duration)\n        case .easeOut:\n            return .easeOut(duration: duration)\n        case .easeInOut:\n            return .easeInOut(duration: duration)\n        case .spring:\n            return .interpolatingSpring(\n                mass: 1.0,\n                stiffness: 200,\n                damping: 20,\n                initialVelocity: 0\n            )\n        }\n    }\n    \n    enum AnimationCurve {\n        case linear\n        case easeIn\n        case easeOut\n        case easeInOut\n        case spring\n    }\n}\n\n// MARK: - Optimized Animation Modifiers\n\nextension View {\n    \n    /// Apply a performance-optimized fade transition\n    /// - Parameters:\n    ///   - isVisible: Whether the view should be visible\n    ///   - duration: Animation duration\n    /// - Returns: View with optimized fade animation\n    func optimizedFade(\n        isVisible: Bool,\n        duration: TimeInterval = AnimationOptimizer.Duration.standard\n    ) -> some View {\n        self\n            .opacity(isVisible ? 1.0 : 0.0)\n            .animation(AnimationOptimizer.optimizedAnimation(duration: duration), value: isVisible)\n    }\n    \n    /// Apply a performance-optimized scale transition\n    /// - Parameters:\n    ///   - scale: Scale factor\n    ///   - anchor: Scale anchor point\n    ///   - animation: Animation type\n    /// - Returns: View with optimized scale animation\n    func optimizedScale(\n        _ scale: CGFloat,\n        anchor: UnitPoint = .center,\n        animation: Animation = AnimationOptimizer.fastSpring\n    ) -> some View {\n        self\n            .scaleEffect(scale, anchor: anchor)\n            .animation(animation, value: scale)\n    }\n    \n    /// Apply a performance-optimized slide transition\n    /// - Parameters:\n    ///   - offset: Offset amount\n    ///   - animation: Animation type\n    /// - Returns: View with optimized slide animation\n    func optimizedSlide(\n        offset: CGSize,\n        animation: Animation = AnimationOptimizer.smoothSpring\n    ) -> some View {\n        self\n            .offset(offset)\n            .animation(animation, value: offset)\n    }\n    \n    /// Apply optimized button press animation\n    /// - Parameter isPressed: Whether button is pressed\n    /// - Returns: View with press animation\n    func optimizedPressEffect(isPressed: Bool) -> some View {\n        self\n            .scaleEffect(isPressed ? 0.95 : 1.0)\n            .opacity(isPressed ? 0.8 : 1.0)\n            .animation(AnimationOptimizer.quickEase, value: isPressed)\n    }\n    \n    /// Apply optimized loading animation\n    /// - Parameter isLoading: Whether view is in loading state\n    /// - Returns: View with loading animation\n    func optimizedLoadingEffect(isLoading: Bool) -> some View {\n        self\n            .opacity(isLoading ? 0.6 : 1.0)\n            .overlay(\n                Group {\n                    if isLoading {\n                        ProgressView()\n                            .tint(.trainSoftBlue)\n                            .scaleEffect(0.8)\n                    }\n                }\n            )\n            .animation(AnimationOptimizer.standardEase, value: isLoading)\n    }\n    \n    /// Apply optimized card appearance animation\n    /// - Parameter isVisible: Whether card should be visible\n    /// - Returns: View with card animation\n    func optimizedCardAppearance(isVisible: Bool) -> some View {\n        self\n            .opacity(isVisible ? 1.0 : 0.0)\n            .scaleEffect(isVisible ? 1.0 : 0.9, anchor: .top)\n            .offset(y: isVisible ? 0 : 20)\n            .animation(\n                AnimationOptimizer.smoothSpring,\n                value: isVisible\n            )\n    }\n    \n    /// Apply optimized list item animation\n    /// - Parameters:\n    ///   - index: Item index for staggered animation\n    ///   - isVisible: Whether item should be visible\n    /// - Returns: View with staggered animation\n    func optimizedListItemAnimation(\n        index: Int,\n        isVisible: Bool\n    ) -> some View {\n        self\n            .opacity(isVisible ? 1.0 : 0.0)\n            .offset(x: isVisible ? 0 : -20)\n            .animation(\n                AnimationOptimizer.smoothSpring\n                    .delay(Double(index) * 0.05),\n                value: isVisible\n            )\n    }\n}\n\n// MARK: - High-Performance List Animations\n\nstruct OptimizedListTransition: ViewModifier {\n    let isVisible: Bool\n    let index: Int\n    \n    func body(content: Content) -> some View {\n        content\n            .opacity(isVisible ? 1.0 : 0.0)\n            .offset(x: isVisible ? 0 : -30)\n            .scaleEffect(isVisible ? 1.0 : 0.95, anchor: .leading)\n            .animation(\n                AnimationOptimizer.smoothSpring\n                    .delay(min(Double(index) * 0.03, 0.3)),\n                value: isVisible\n            )\n    }\n}\n\n// MARK: - Performance Monitoring for Animations\n\nstruct AnimationPerformanceMonitor: ViewModifier {\n    let animationName: String\n    @State private var animationStartTime: Date?\n    \n    private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? \"TrainAlert\", category: \"Animation\")\n    private let performanceMonitor = PerformanceMonitor.shared\n    \n    func body(content: Content) -> some View {\n        content\n            .onAppear {\n                animationStartTime = Date()\n                performanceMonitor.startTimer(for: \"Animation: \\(animationName)\")\n            }\n            .onDisappear {\n                if let startTime = animationStartTime {\n                    let duration = Date().timeIntervalSince(startTime)\n                    performanceMonitor.endTimer(for: \"Animation: \\(animationName)\")\n                    \n                    if duration > 0.5 {\n                        logger.warning(\"Long-running animation detected: \\(animationName) took \\(duration)s\")\n                    }\n                }\n            }\n    }\n}\n\nextension View {\n    /// Monitor animation performance\n    func monitorAnimationPerformance(_ animationName: String) -> some View {\n        modifier(AnimationPerformanceMonitor(animationName: animationName))\n    }\n}\n\n// MARK: - Memory-Efficient Animation State\n\n/// Lightweight animation state manager\n@propertyWrapper\nstruct AnimationState<T: Equatable> {\n    private var value: T\n    private let animation: Animation\n    \n    var wrappedValue: T {\n        get { value }\n        nonmutating set {\n            withAnimation(animation) {\n                value = newValue\n            }\n        }\n    }\n    \n    var projectedValue: T {\n        get { value }\n        set { value = newValue }\n    }\n    \n    init(wrappedValue: T, animation: Animation = AnimationOptimizer.standardEase) {\n        self.value = wrappedValue\n        self.animation = animation\n    }\n}\n\n// MARK: - Optimized Transition Effects\n\nstruct SlideInTransition: ViewModifier {\n    let isVisible: Bool\n    let edge: Edge\n    let distance: CGFloat\n    \n    func body(content: Content) -> some View {\n        let offset: CGSize = {\n            switch edge {\n            case .leading:\n                return CGSize(width: isVisible ? 0 : -distance, height: 0)\n            case .trailing:\n                return CGSize(width: isVisible ? 0 : distance, height: 0)\n            case .top:\n                return CGSize(width: 0, height: isVisible ? 0 : -distance)\n            case .bottom:\n                return CGSize(width: 0, height: isVisible ? 0 : distance)\n            }\n        }()\n        \n        content\n            .offset(offset)\n            .opacity(isVisible ? 1.0 : 0.0)\n            .animation(AnimationOptimizer.smoothSpring, value: isVisible)\n    }\n}\n\nstruct ScaleTransition: ViewModifier {\n    let isVisible: Bool\n    let scale: CGFloat\n    let anchor: UnitPoint\n    \n    func body(content: Content) -> some View {\n        content\n            .scaleEffect(isVisible ? 1.0 : scale, anchor: anchor)\n            .opacity(isVisible ? 1.0 : 0.0)\n            .animation(AnimationOptimizer.smoothSpring, value: isVisible)\n    }\n}\n\nextension View {\n    /// Apply optimized slide-in transition\n    func slideIn(\n        isVisible: Bool,\n        from edge: Edge,\n        distance: CGFloat = 100\n    ) -> some View {\n        modifier(SlideInTransition(\n            isVisible: isVisible,\n            edge: edge,\n            distance: distance\n        ))\n    }\n    \n    /// Apply optimized scale transition\n    func scaleTransition(\n        isVisible: Bool,\n        scale: CGFloat = 0.8,\n        anchor: UnitPoint = .center\n    ) -> some View {\n        modifier(ScaleTransition(\n            isVisible: isVisible,\n            scale: scale,\n            anchor: anchor\n        ))\n    }\n}\n\n// MARK: - 60FPS Animation Guidelines\n\n/// Guidelines for maintaining 60fps animations\nenum AnimationGuidelines {\n    \n    /// Maximum recommended animation duration for smooth performance\n    static let maxRecommendedDuration: TimeInterval = 0.8\n    \n    /// Maximum number of concurrent animations\n    static let maxConcurrentAnimations: Int = 3\n    \n    /// Recommended frame rate target\n    static let targetFrameRate: Double = 60.0\n    \n    /// Check if animation duration is performance-friendly\n    static func isOptimizedDuration(_ duration: TimeInterval) -> Bool {\n        return duration <= maxRecommendedDuration\n    }\n    \n    /// Get recommended easing for animation duration\n    static func recommendedEasing(for duration: TimeInterval) -> Animation {\n        switch duration {\n        case 0...0.2:\n            return AnimationOptimizer.quickEase\n        case 0.2...0.4:\n            return AnimationOptimizer.standardEase\n        case 0.4...0.8:\n            return AnimationOptimizer.slowEase\n        default:\n            return AnimationOptimizer.gentleSpring\n        }\n    }\n}
