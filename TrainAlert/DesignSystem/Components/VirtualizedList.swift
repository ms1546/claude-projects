//\n//  VirtualizedList.swift\n//  TrainAlert\n//\n//  Created by Claude on 2024/01/08.\n//\n\nimport SwiftUI\nimport OSLog\n\n/// High-performance virtualized list that only renders visible items\n/// Optimized for handling large datasets while maintaining smooth scrolling\nstruct VirtualizedList<Item: Identifiable & Equatable, Content: View>: View {\n    \n    // MARK: - Properties\n    \n    private let items: [Item]\n    private let itemHeight: CGFloat\n    private let content: (Item) -> Content\n    private let onLoadMore: (() -> Void)?\n    private let loadMoreThreshold: Int\n    \n    @State private var visibleRange: Range<Int> = 0..<0\n    @State private var contentOffset: CGFloat = 0\n    @State private var containerHeight: CGFloat = 0\n    \n    // Performance monitoring\n    private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? \"TrainAlert\", category: \"VirtualizedList\")\n    private let performanceMonitor = PerformanceMonitor.shared\n    \n    // MARK: - Configuration\n    \n    private struct Config {\n        static let bufferSize: Int = 5 // Extra items to render above/below visible area\n        static let batchSize: Int = 20 // Items to load per batch\n        static let estimatedItemHeight: CGFloat = 80\n    }\n    \n    // MARK: - Initialization\n    \n    /// Initialize virtualized list\n    /// - Parameters:\n    ///   - items: Array of items to display\n    ///   - itemHeight: Height of each item (fixed height required for virtualization)\n    ///   - loadMoreThreshold: Number of items from end to trigger load more\n    ///   - onLoadMore: Callback for loading more items\n    ///   - content: Content builder for each item\n    init(\n        items: [Item],\n        itemHeight: CGFloat = Config.estimatedItemHeight,\n        loadMoreThreshold: Int = 10,\n        onLoadMore: (() -> Void)? = nil,\n        @ViewBuilder content: @escaping (Item) -> Content\n    ) {\n        self.items = items\n        self.itemHeight = itemHeight\n        self.loadMoreThreshold = loadMoreThreshold\n        self.onLoadMore = onLoadMore\n        self.content = content\n    }\n    \n    // MARK: - Body\n    \n    var body: some View {\n        GeometryReader { geometry in\n            ScrollViewReader { proxy in\n                ScrollView(.vertical, showsIndicators: true) {\n                    LazyVStack(spacing: 0) {\n                        // Spacer for items above visible range\n                        if visibleRange.lowerBound > 0 {\n                            Spacer()\n                                .frame(height: CGFloat(visibleRange.lowerBound) * itemHeight)\n                        }\n                        \n                        // Visible items\n                        ForEach(Array(visibleItems.enumerated()), id: \\.element.id) { index, item in\n                            content(item)\n                                .frame(height: itemHeight)\n                                .id(item.id)\n                                .optimizedListItemAnimation(\n                                    index: index,\n                                    isVisible: true\n                                )\n                                .onAppear {\n                                    checkForLoadMore(itemIndex: actualIndex(for: index))\n                                }\n                        }\n                        \n                        // Spacer for items below visible range\n                        let remainingItems = items.count - visibleRange.upperBound\n                        if remainingItems > 0 {\n                            Spacer()\n                                .frame(height: CGFloat(remainingItems) * itemHeight)\n                        }\n                        \n                        // Loading indicator\n                        if onLoadMore != nil {\n                            LoadingFooter()\n                                .frame(height: 60)\n                        }\n                    }\n                }\n                .coordinateSpace(name: \"scroll\")\n                .onPreferenceChange(ScrollOffsetPreferenceKey.self) { offset in\n                    handleScrollOffset(offset, containerHeight: geometry.size.height)\n                }\n            }\n        }\n        .onAppear {\n            containerHeight = UIScreen.main.bounds.height\n            updateVisibleRange()\n            \n            logger.debug(\"VirtualizedList initialized with \\(items.count) items\")\n            performanceMonitor.logMemoryUsage(context: \"VirtualizedList Appear\")\n        }\n        .monitorAnimationPerformance(\"VirtualizedList\")\n    }\n    \n    // MARK: - Computed Properties\n    \n    private var visibleItems: ArraySlice<Item> {\n        guard visibleRange.upperBound <= items.count else {\n            return items[visibleRange.lowerBound..<items.count]\n        }\n        return items[visibleRange]\n    }\n    \n    private var totalContentHeight: CGFloat {\n        CGFloat(items.count) * itemHeight\n    }\n    \n    // MARK: - Private Methods\n    \n    private func handleScrollOffset(_ offset: CGFloat, containerHeight: CGFloat) {\n        guard containerHeight > 0 else { return }\n        \n        let newOffset = -offset // ScrollView offset is negative\n        \n        // Throttle updates to improve performance\n        if abs(newOffset - contentOffset) > itemHeight / 2 {\n            contentOffset = newOffset\n            updateVisibleRange()\n        }\n    }\n    \n    private func updateVisibleRange() {\n        guard itemHeight > 0 && containerHeight > 0 else { return }\n        \n        performanceMonitor.startTimer(for: \"Update Visible Range\")\n        \n        let visibleItems = Int(containerHeight / itemHeight) + 1\n        let startIndex = max(0, Int(contentOffset / itemHeight) - Config.bufferSize)\n        let endIndex = min(items.count, startIndex + visibleItems + (Config.bufferSize * 2))\n        \n        let newRange = startIndex..<endIndex\n        \n        if newRange != visibleRange {\n            visibleRange = newRange\n            logger.debug(\"Updated visible range: \\(startIndex)-\\(endIndex) of \\(items.count)\")\n        }\n        \n        performanceMonitor.endTimer(for: \"Update Visible Range\")\n    }\n    \n    private func actualIndex(for visibleIndex: Int) -> Int {\n        return visibleRange.lowerBound + visibleIndex\n    }\n    \n    private func checkForLoadMore(itemIndex: Int) {\n        guard let onLoadMore = onLoadMore,\n              itemIndex >= items.count - loadMoreThreshold else { return }\n        \n        logger.debug(\"Triggering load more at index \\(itemIndex)\")\n        onLoadMore()\n    }\n}\n\n// MARK: - Supporting Views\n\nprivate struct LoadingFooter: View {\n    var body: some View {\n        HStack {\n            Spacer()\n            \n            ProgressView()\n                .tint(.softBlue)\n                .scaleEffect(0.8)\n            \n            Text(\"読み込み中...\")\n                .font(.caption)\n                .foregroundColor(.lightGray)\n                .padding(.leading, 8)\n            \n            Spacer()\n        }\n        .padding()\n    }\n}\n\n// MARK: - Scroll Offset Tracking\n\nstruct ScrollOffsetPreferenceKey: PreferenceKey {\n    static var defaultValue: CGFloat = 0\n    \n    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {\n        value = nextValue()\n    }\n}\n\nstruct ScrollOffsetModifier: ViewModifier {\n    let coordinateSpace: String\n    \n    func body(content: Content) -> some View {\n        content\n            .background(\n                GeometryReader { geometry in\n                    Color.clear\n                        .preference(\n                            key: ScrollOffsetPreferenceKey.self,\n                            value: geometry.frame(in: .named(coordinateSpace)).minY\n                        )\n                }\n            )\n    }\n}\n\n// MARK: - Paginated Data Source\n\n/// Data source for handling paginated loading\nclass PaginatedDataSource<T: Identifiable & Equatable>: ObservableObject {\n    \n    // MARK: - Properties\n    \n    @Published var items: [T] = []\n    @Published var isLoading = false\n    @Published var hasMoreData = true\n    @Published var error: Error?\n    \n    private let batchSize: Int\n    private let loadData: (Int, Int) async throws -> [T]\n    private var currentPage = 0\n    \n    private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? \"TrainAlert\", category: \"PaginatedDataSource\")\n    private let backgroundProcessor = BackgroundProcessingManager.shared\n    \n    // MARK: - Initialization\n    \n    init(\n        batchSize: Int = 20,\n        loadData: @escaping (Int, Int) async throws -> [T]\n    ) {\n        self.batchSize = batchSize\n        self.loadData = loadData\n    }\n    \n    // MARK: - Public Methods\n    \n    /// Load initial data\n    @MainActor\n    func loadInitialData() async {\n        guard !isLoading else { return }\n        \n        isLoading = true\n        error = nil\n        currentPage = 0\n        \n        do {\n            let newItems = try await backgroundProcessor.executeNormalPriority {\n                try await self.loadData(0, self.batchSize)\n            }\n            \n            items = newItems\n            hasMoreData = newItems.count == batchSize\n            currentPage = 1\n            \n            logger.info(\"Loaded \\(newItems.count) initial items\")\n            \n        } catch {\n            self.error = error\n            logger.error(\"Failed to load initial data: \\(error.localizedDescription)\")\n        }\n        \n        isLoading = false\n    }\n    \n    /// Load more data\n    @MainActor\n    func loadMoreData() async {\n        guard !isLoading && hasMoreData else { return }\n        \n        isLoading = true\n        \n        do {\n            let newItems = try await backgroundProcessor.executeNormalPriority {\n                try await self.loadData(self.currentPage * self.batchSize, self.batchSize)\n            }\n            \n            if newItems.isEmpty {\n                hasMoreData = false\n            } else {\n                items.append(contentsOf: newItems)\n                currentPage += 1\n                hasMoreData = newItems.count == batchSize\n            }\n            \n            logger.debug(\"Loaded \\(newItems.count) more items, total: \\(items.count)\")\n            \n        } catch {\n            self.error = error\n            logger.error(\"Failed to load more data: \\(error.localizedDescription)\")\n        }\n        \n        isLoading = false\n    }\n    \n    /// Refresh all data\n    @MainActor\n    func refresh() async {\n        currentPage = 0\n        hasMoreData = true\n        items.removeAll()\n        await loadInitialData()\n    }\n}\n\n// MARK: - Optimized History List\n\n/// Specialized virtualized list for history items\nstruct OptimizedHistoryList: View {\n    \n    @StateObject private var dataSource: PaginatedDataSource<History>\n    @State private var isInitialLoadComplete = false\n    \n    private let coreDataManager: CoreDataManager\n    \n    init(coreDataManager: CoreDataManager = CoreDataManager.shared) {\n        self.coreDataManager = coreDataManager\n        \n        self._dataSource = StateObject(wrappedValue: PaginatedDataSource<History> { offset, limit in\n            try await coreDataManager.fetchHistoryAsync(limit: limit, offset: offset)\n        })\n    }\n    \n    var body: some View {\n        Group {\n            if dataSource.items.isEmpty && dataSource.isLoading {\n                LoadingView()\n            } else if dataSource.items.isEmpty {\n                EmptyHistoryView()\n            } else {\n                VirtualizedList(\n                    items: dataSource.items,\n                    itemHeight: 80,\n                    loadMoreThreshold: 10,\n                    onLoadMore: {\n                        Task {\n                            await dataSource.loadMoreData()\n                        }\n                    }\n                ) { history in\n                    HistoryRowView(history: history)\n                }\n            }\n        }\n        .onAppear {\n            if !isInitialLoadComplete {\n                Task {\n                    await dataSource.loadInitialData()\n                    isInitialLoadComplete = true\n                }\n            }\n        }\n        .refreshable {\n            await dataSource.refresh()\n        }\n    }\n}\n\n// MARK: - Supporting Views\n\nprivate struct LoadingView: View {\n    var body: some View {\n        VStack {\n            ProgressView()\n                .tint(.softBlue)\n                .scaleEffect(1.2)\n            \n            Text(\"履歴を読み込み中...\")\n                .font(.caption)\n                .foregroundColor(.lightGray)\n                .padding(.top, 8)\n        }\n        .frame(maxWidth: .infinity, maxHeight: .infinity)\n    }\n}\n\nprivate struct EmptyHistoryView: View {\n    var body: some View {\n        VStack(spacing: 16) {\n            Image(systemName: \"clock\")\n                .font(.system(size: 48))\n                .foregroundColor(.lightGray)\n            \n            Text(\"履歴がありません\")\n                .font(.headline)\n                .foregroundColor(.lightGray)\n            \n            Text(\"アラートを設定して通知履歴を確認しましょう\")\n                .font(.caption)\n                .foregroundColor(.lightGray)\n                .multilineTextAlignment(.center)\n        }\n        .padding()\n        .frame(maxWidth: .infinity, maxHeight: .infinity)\n    }\n}\n\nprivate struct HistoryRowView: View {\n    let history: History\n    \n    var body: some View {\n        HStack {\n            VStack(alignment: .leading, spacing: 4) {\n                Text(history.message ?? \"通知メッセージ\")\n                    .font(.body)\n                    .foregroundColor(.white)\n                    .lineLimit(2)\n                \n                if let date = history.notifiedAt {\n                    Text(DateFormatter.historyFormatter.string(from: date))\n                        .font(.caption)\n                        .foregroundColor(.lightGray)\n                }\n            }\n            \n            Spacer()\n            \n            if let stationName = history.alert?.station?.name {\n                Text(stationName)\n                    .font(.caption)\n                    .foregroundColor(.softBlue)\n                    .padding(.horizontal, 8)\n                    .padding(.vertical, 4)\n                    .background(.softBlue.opacity(0.2))\n                    .clipShape(RoundedRectangle(cornerRadius: 4))\n            }\n        }\n        .padding(.horizontal, 16)\n        .padding(.vertical, 12)\n        .background(.charcoalGray)\n    }\n}\n\n// MARK: - Extensions\n\nextension DateFormatter {\n    static let historyFormatter: DateFormatter = {\n        let formatter = DateFormatter()\n        formatter.dateStyle = .short\n        formatter.timeStyle = .short\n        return formatter\n    }()\n}