//\n//  ImageCacheManager.swift\n//  TrainAlert\n//\n//  Created by Claude on 2024/01/08.\n//\n\nimport UIKit\nimport SwiftUI\nimport Combine\nimport OSLog\n\n/// High-performance image caching manager with memory management and automatic cleanup\nfinal class ImageCacheManager: ObservableObject {\n    \n    // MARK: - Singleton\n    \n    static let shared = ImageCacheManager()\n    \n    // MARK: - Properties\n    \n    private let memoryCache = NSCache<NSString, UIImage>()\n    private let diskCache: DiskCache\n    private let downloadQueue = DispatchQueue(label: \"com.trainalert.image-download\", qos: .utility)\n    private let cacheQueue = DispatchQueue(label: \"com.trainalert.image-cache\", qos: .utility)\n    \n    private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? \"TrainAlert\", category: \"ImageCache\")\n    private let performanceMonitor = PerformanceMonitor.shared\n    \n    private var activeDownloads: [String: Task<UIImage?, Never>] = [:]\n    private let activeDownloadsLock = NSLock()\n    \n    // MARK: - Configuration\n    \n    private struct CacheConfig {\n        static let memoryLimit = 50 * 1024 * 1024 // 50MB\n        static let diskLimit = 100 * 1024 * 1024  // 100MB\n        static let maxConcurrentDownloads = 4\n        static let cacheExpiration: TimeInterval = 7 * 24 * 60 * 60 // 1 week\n        static let cleanupInterval: TimeInterval = 24 * 60 * 60 // 1 day\n    }\n    \n    // MARK: - Initialization\n    \n    private init() {\n        self.diskCache = DiskCache()\n        setupMemoryCache()\n        setupMemoryWarningNotification()\n        schedulePeriodicCleanup()\n        \n        logger.info(\"ImageCacheManager initialized with memory limit: \\(CacheConfig.memoryLimit / 1024 / 1024)MB\")\n    }\n    \n    private func setupMemoryCache() {\n        memoryCache.totalCostLimit = CacheConfig.memoryLimit\n        memoryCache.countLimit = 100 // Maximum number of images\n        \n        // Set eviction policy\n        memoryCache.evictsObjectsWithDiscardedContent = true\n    }\n    \n    private func setupMemoryWarningNotification() {\n        NotificationCenter.default.addObserver(\n            self,\n            selector: #selector(handleMemoryWarning),\n            name: UIApplication.didReceiveMemoryWarningNotification,\n            object: nil\n        )\n    }\n    \n    @objc private func handleMemoryWarning() {\n        logger.warning(\"Memory warning received, clearing image cache\")\n        clearMemoryCache()\n    }\n    \n    private func schedulePeriodicCleanup() {\n        Timer.scheduledTimer(withTimeInterval: CacheConfig.cleanupInterval, repeats: true) { [weak self] _ in\n            Task {\n                await self?.performDiskCleanup()\n            }\n        }\n    }\n    \n    // MARK: - Public API\n    \n    /// Load image with caching and performance optimization\n    func loadImage(from urlString: String) async -> UIImage? {\n        let cacheKey = cacheKey(for: urlString)\n        \n        // Check memory cache first\n        if let cachedImage = memoryCache.object(forKey: cacheKey as NSString) {\n            logger.debug(\"Image loaded from memory cache: \\(urlString)\")\n            return cachedImage\n        }\n        \n        // Check if download is already in progress\n        activeDownloadsLock.lock()\n        if let existingTask = activeDownloads[cacheKey] {\n            activeDownloadsLock.unlock()\n            return await existingTask.value\n        }\n        \n        // Create new download task\n        let downloadTask = Task<UIImage?, Never> {\n            await performImageLoad(urlString: urlString, cacheKey: cacheKey)\n        }\n        \n        activeDownloads[cacheKey] = downloadTask\n        activeDownloadsLock.unlock()\n        \n        let image = await downloadTask.value\n        \n        // Remove from active downloads\n        activeDownloadsLock.lock()\n        activeDownloads.removeValue(forKey: cacheKey)\n        activeDownloadsLock.unlock()\n        \n        return image\n    }\n    \n    /// Load image synchronously from cache only\n    func cachedImage(for urlString: String) -> UIImage? {\n        let cacheKey = cacheKey(for: urlString)\n        return memoryCache.object(forKey: cacheKey as NSString)\n    }\n    \n    /// Cache image in memory and disk\n    func cacheImage(_ image: UIImage, for urlString: String) {\n        let cacheKey = cacheKey(for: urlString)\n        let cost = imageCost(image)\n        \n        // Store in memory cache\n        memoryCache.setObject(image, forKey: cacheKey as NSString, cost: cost)\n        \n        // Store in disk cache asynchronously\n        Task {\n            await diskCache.store(image: image, key: cacheKey)\n        }\n        \n        logger.debug(\"Image cached with cost \\(cost) bytes: \\(urlString)\")\n    }\n    \n    /// Clear all caches\n    func clearAllCaches() async {\n        clearMemoryCache()\n        await diskCache.clearAll()\n        \n        // Cancel active downloads\n        activeDownloadsLock.lock()\n        for task in activeDownloads.values {\n            task.cancel()\n        }\n        activeDownloads.removeAll()\n        activeDownloadsLock.unlock()\n        \n        logger.info(\"All caches cleared\")\n    }\n    \n    /// Clear memory cache only\n    func clearMemoryCache() {\n        memoryCache.removeAllObjects()\n        logger.info(\"Memory cache cleared\")\n    }\n    \n    /// Get cache statistics\n    func getCacheStats() -> CacheStats {\n        let memoryUsage = memoryCache.totalCostLimit\n        let diskUsage = diskCache.totalSize\n        \n        return CacheStats(\n            memoryUsage: memoryUsage,\n            diskUsage: diskUsage,\n            activeDownloads: activeDownloads.count\n        )\n    }\n    \n    // MARK: - Private Methods\n    \n    private func performImageLoad(urlString: String, cacheKey: String) async -> UIImage? {\n        performanceMonitor.startTimer(for: \"Image Load: \\(urlString)\")\n        defer { performanceMonitor.endTimer(for: \"Image Load: \\(urlString)\") }\n        \n        // Check disk cache\n        if let diskImage = await diskCache.image(for: cacheKey) {\n            // Store in memory cache for faster access\n            let cost = imageCost(diskImage)\n            memoryCache.setObject(diskImage, forKey: cacheKey as NSString, cost: cost)\n            \n            logger.debug(\"Image loaded from disk cache: \\(urlString)\")\n            return diskImage\n        }\n        \n        // Download from network\n        return await downloadImage(from: urlString, cacheKey: cacheKey)\n    }\n    \n    private func downloadImage(from urlString: String, cacheKey: String) async -> UIImage? {\n        guard let url = URL(string: urlString) else {\n            logger.error(\"Invalid URL: \\(urlString)\")\n            return nil\n        }\n        \n        do {\n            performanceMonitor.startTimer(for: \"Image Download: \\(urlString)\")\n            \n            let (data, response) = try await URLSession.shared.data(from: url)\n            \n            performanceMonitor.endTimer(for: \"Image Download: \\(urlString)\")\n            \n            guard let httpResponse = response as? HTTPURLResponse,\n                  httpResponse.statusCode == 200 else {\n                logger.error(\"HTTP error for image: \\(urlString)\")\n                return nil\n            }\n            \n            guard let image = UIImage(data: data) else {\n                logger.error(\"Failed to create image from data: \\(urlString)\")\n                return nil\n            }\n            \n            // Optimize image for display\n            let optimizedImage = optimizeImage(image)\n            \n            // Cache the image\n            cacheImage(optimizedImage, for: urlString)\n            \n            logger.info(\"Image downloaded and cached: \\(urlString)\")\n            return optimizedImage\n            \n        } catch {\n            logger.error(\"Failed to download image: \\(error.localizedDescription)\")\n            return nil\n        }\n    }\n    \n    private func optimizeImage(_ image: UIImage) -> UIImage {\n        // Optimize for memory usage by decompressing on background thread\n        guard let cgImage = image.cgImage else { return image }\n        \n        let colorSpace = CGColorSpaceCreateDeviceRGB()\n        let bitmapInfo = CGBitmapInfo.byteOrder32Host.rawValue | CGImageAlphaInfo.noneSkipFirst.rawValue\n        \n        guard let context = CGContext(\n            data: nil,\n            width: cgImage.width,\n            height: cgImage.height,\n            bitsPerComponent: 8,\n            bytesPerRow: 0,\n            space: colorSpace,\n            bitmapInfo: bitmapInfo\n        ) else { return image }\n        \n        context.draw(cgImage, in: CGRect(x: 0, y: 0, width: cgImage.width, height: cgImage.height))\n        \n        guard let optimizedCGImage = context.makeImage() else { return image }\n        \n        return UIImage(cgImage: optimizedCGImage, scale: image.scale, orientation: image.imageOrientation)\n    }\n    \n    private func cacheKey(for urlString: String) -> String {\n        return urlString.sha256\n    }\n    \n    private func imageCost(_ image: UIImage) -> Int {\n        guard let cgImage = image.cgImage else { return 0 }\n        return cgImage.bytesPerRow * cgImage.height\n    }\n    \n    private func performDiskCleanup() async {\n        performanceMonitor.startTimer(for: \"Disk Cache Cleanup\")\n        \n        await diskCache.cleanupExpiredFiles(olderThan: CacheConfig.cacheExpiration)\n        await diskCache.enforceStorageLimit(CacheConfig.diskLimit)\n        \n        performanceMonitor.endTimer(for: \"Disk Cache Cleanup\")\n        performanceMonitor.logMemoryUsage(context: \"After Disk Cleanup\")\n    }\n}\n\n// MARK: - Supporting Types\n\nstruct CacheStats {\n    let memoryUsage: Int\n    let diskUsage: Int\n    let activeDownloads: Int\n}\n\n// MARK: - Disk Cache\n\nprivate actor DiskCache {\n    \n    private let cacheDirectory: URL\n    private let fileManager = FileManager.default\n    private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? \"TrainAlert\", category: \"DiskCache\")\n    \n    init() {\n        let cachesDirectory = fileManager.urls(for: .cachesDirectory, in: .userDomainMask).first!\n        self.cacheDirectory = cachesDirectory.appendingPathComponent(\"ImageCache\")\n        \n        // Create cache directory if it doesn't exist\n        try? fileManager.createDirectory(at: cacheDirectory, withIntermediateDirectories: true)\n    }\n    \n    func store(image: UIImage, key: String) {\n        guard let data = image.pngData() else { return }\n        \n        let fileURL = cacheDirectory.appendingPathComponent(key)\n        \n        do {\n            try data.write(to: fileURL)\n            \n            // Set file attributes for cleanup\n            try fileManager.setAttributes(\n                [.creationDate: Date()],\n                ofItemAtPath: fileURL.path\n            )\n            \n        } catch {\n            logger.error(\"Failed to store image to disk: \\(error.localizedDescription)\")\n        }\n    }\n    \n    func image(for key: String) -> UIImage? {\n        let fileURL = cacheDirectory.appendingPathComponent(key)\n        \n        guard fileManager.fileExists(atPath: fileURL.path),\n              let data = try? Data(contentsOf: fileURL),\n              let image = UIImage(data: data) else {\n            return nil\n        }\n        \n        // Update access time\n        try? fileManager.setAttributes(\n            [.modificationDate: Date()],\n            ofItemAtPath: fileURL.path\n        )\n        \n        return image\n    }\n    \n    func clearAll() {\n        do {\n            let files = try fileManager.contentsOfDirectory(at: cacheDirectory, includingPropertiesForKeys: nil)\n            for file in files {\n                try fileManager.removeItem(at: file)\n            }\n            logger.info(\"Disk cache cleared\")\n        } catch {\n            logger.error(\"Failed to clear disk cache: \\(error.localizedDescription)\")\n        }\n    }\n    \n    func cleanupExpiredFiles(olderThan timeInterval: TimeInterval) {\n        do {\n            let files = try fileManager.contentsOfDirectory(\n                at: cacheDirectory,\n                includingPropertiesForKeys: [.creationDateKey]\n            )\n            \n            let cutoffDate = Date().addingTimeInterval(-timeInterval)\n            var removedCount = 0\n            \n            for file in files {\n                let attributes = try fileManager.attributesOfItem(atPath: file.path)\n                \n                if let creationDate = attributes[.creationDate] as? Date,\n                   creationDate < cutoffDate {\n                    try fileManager.removeItem(at: file)\n                    removedCount += 1\n                }\n            }\n            \n            if removedCount > 0 {\n                logger.info(\"Removed \\(removedCount) expired cache files\")\n            }\n            \n        } catch {\n            logger.error(\"Failed to cleanup expired files: \\(error.localizedDescription)\")\n        }\n    }\n    \n    func enforceStorageLimit(_ limit: Int) {\n        do {\n            let files = try fileManager.contentsOfDirectory(\n                at: cacheDirectory,\n                includingPropertiesForKeys: [.fileSizeKey, .modificationDateKey]\n            )\n            \n            // Calculate total size\n            let totalSize = files.compactMap { file in\n                try? fileManager.attributesOfItem(atPath: file.path)[.size] as? Int\n            }.reduce(0, +)\n            \n            guard totalSize > limit else { return }\n            \n            // Sort by last modified date (oldest first)\n            let sortedFiles = files.sorted { file1, file2 in\n                let date1 = (try? fileManager.attributesOfItem(atPath: file1.path)[.modificationDate] as? Date) ?? Date.distantPast\n                let date2 = (try? fileManager.attributesOfItem(atPath: file2.path)[.modificationDate] as? Date) ?? Date.distantPast\n                return date1 < date2\n            }\n            \n            var currentSize = totalSize\n            var removedCount = 0\n            \n            for file in sortedFiles {\n                guard currentSize > limit else { break }\n                \n                if let fileSize = try? fileManager.attributesOfItem(atPath: file.path)[.size] as? Int {\n                    try fileManager.removeItem(at: file)\n                    currentSize -= fileSize\n                    removedCount += 1\n                }\n            }\n            \n            if removedCount > 0 {\n                logger.info(\"Removed \\(removedCount) files to enforce storage limit\")\n            }\n            \n        } catch {\n            logger.error(\"Failed to enforce storage limit: \\(error.localizedDescription)\")\n        }\n    }\n    \n    var totalSize: Int {\n        do {\n            let files = try fileManager.contentsOfDirectory(at: cacheDirectory, includingPropertiesForKeys: [.fileSizeKey])\n            return files.compactMap { file in\n                try? fileManager.attributesOfItem(atPath: file.path)[.size] as? Int\n            }.reduce(0, +)\n        } catch {\n            return 0\n        }\n    }\n}\n\n// MARK: - String Extensions\n\nprivate extension String {\n    var sha256: String {\n        let data = self.data(using: .utf8)!\n        var hash = [UInt8](repeating: 0, count: Int(CC_SHA256_DIGEST_LENGTH))\n        \n        data.withUnsafeBytes {\n            _ = CC_SHA256($0.baseAddress, CC_LONG(data.count), &hash)\n        }\n        \n        return hash.map { String(format: \"%02x\", $0) }.joined()\n    }\n}\n\n// MARK: - CommonCrypto Import\n\nimport CommonCrypto