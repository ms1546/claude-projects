//\n//  NetworkOptimizationManager.swift\n//  TrainAlert\n//\n//  Created by Claude on 2024/01/08.\n//\n\nimport Foundation\nimport Network\nimport OSLog\nimport Combine\n\n/// Network optimization manager for reducing API calls and improving performance\nfinal class NetworkOptimizationManager: ObservableObject {\n    \n    // MARK: - Singleton\n    \n    static let shared = NetworkOptimizationManager()\n    \n    // MARK: - Properties\n    \n    private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? \"TrainAlert\", category: \"NetworkOptimization\")\n    private let performanceMonitor = PerformanceMonitor.shared\n    \n    // Request caching and deduplication\n    private var requestCache: [String: CachedResponse] = [:]\n    private let cacheLock = NSLock()\n    \n    // Active requests to prevent duplicates\n    private var activeRequests: [String: Task<Data, Error>] = [:]\n    private let activeRequestsLock = NSLock()\n    \n    // Batch request queue\n    private var batchQueue: [BatchRequest] = []\n    private let batchLock = NSLock()\n    private var batchTimer: Timer?\n    \n    // Network monitoring\n    private let networkMonitor = NWPathMonitor()\n    @Published var networkStatus: NetworkStatus = .unknown\n    @Published var isLowDataMode = false\n    \n    // Configuration\n    private struct Config {\n        static let cacheExpirationTime: TimeInterval = 300 // 5 minutes\n        static let batchDelay: TimeInterval = 0.5 // 500ms\n        static let maxBatchSize: Int = 10\n        static let requestTimeout: TimeInterval = 15\n        static let maxConcurrentRequests = 4\n    }\n    \n    // MARK: - Initialization\n    \n    private init() {\n        setupNetworkMonitoring()\n        logger.info(\"NetworkOptimizationManager initialized\")\n    }\n    \n    deinit {\n        cleanup()\n    }\n    \n    // MARK: - Public API\n    \n    /// Execute optimized network request with caching and deduplication\n    /// - Parameters:\n    ///   - request: URL request\n    ///   - cachePolicy: Cache policy to use\n    ///   - priority: Request priority\n    /// - Returns: Response data\n    func executeRequest(\n        _ request: URLRequest,\n        cachePolicy: CachePolicy = .default,\n        priority: RequestPriority = .normal\n    ) async throws -> Data {\n        \n        let requestKey = createRequestKey(from: request)\n        \n        // Check cache first\n        if let cachedData = getCachedResponse(for: requestKey, policy: cachePolicy) {\n            logger.debug(\"Using cached response for: \\(request.url?.absoluteString ?? \"unknown\")\")\n            return cachedData\n        }\n        \n        // Check for active request\n        activeRequestsLock.lock()\n        if let existingTask = activeRequests[requestKey] {\n            activeRequestsLock.unlock()\n            logger.debug(\"Waiting for existing request: \\(request.url?.absoluteString ?? \"unknown\")\")\n            return try await existingTask.value\n        }\n        activeRequestsLock.unlock()\n        \n        // Create new request task\n        let requestTask = Task<Data, Error> {\n            try await executeNetworkRequest(request, priority: priority)\n        }\n        \n        // Track active request\n        activeRequestsLock.lock()\n        activeRequests[requestKey] = requestTask\n        activeRequestsLock.unlock()\n        \n        defer {\n            activeRequestsLock.lock()\n            activeRequests.removeValue(forKey: requestKey)\n            activeRequestsLock.unlock()\n        }\n        \n        do {\n            let data = try await requestTask.value\n            \n            // Cache successful response\n            cacheResponse(data: data, for: requestKey, policy: cachePolicy)\n            \n            return data\n        } catch {\n            logger.error(\"Network request failed: \\(error.localizedDescription)\")\n            throw error\n        }\n    }\n    \n    /// Add request to batch queue for processing\n    /// - Parameters:\n    ///   - request: URL request\n    ///   - completion: Completion handler\n    func addToBatchQueue<T>(\n        _ request: URLRequest,\n        responseType: T.Type,\n        completion: @escaping (Result<T, Error>) -> Void\n    ) where T: Decodable {\n        \n        let batchRequest = BatchRequest(\n            request: request,\n            responseType: responseType,\n            completion: { result in\n                switch result {\n                case .success(let data):\n                    do {\n                        let decodedResponse = try JSONDecoder().decode(T.self, from: data)\n                        completion(.success(decodedResponse))\n                    } catch {\n                        completion(.failure(error))\n                    }\n                case .failure(let error):\n                    completion(.failure(error))\n                }\n            }\n        )\n        \n        batchLock.lock()\n        batchQueue.append(batchRequest)\n        let shouldProcess = batchQueue.count >= Config.maxBatchSize\n        batchLock.unlock()\n        \n        if shouldProcess {\n            processBatchQueue()\n        } else {\n            scheduleBatchProcessing()\n        }\n    }\n    \n    /// Execute multiple requests concurrently with optimization\n    /// - Parameters:\n    ///   - requests: Array of URL requests\n    ///   - maxConcurrency: Maximum concurrent requests\n    /// - Returns: Array of response data\n    func executeConcurrentRequests(\n        _ requests: [URLRequest],\n        maxConcurrency: Int = Config.maxConcurrentRequests\n    ) async throws -> [Data] {\n        \n        performanceMonitor.startTimer(for: \"Concurrent Network Requests\")\n        defer { performanceMonitor.endTimer(for: \"Concurrent Network Requests\") }\n        \n        return try await withThrowingTaskGroup(of: (Int, Data).self, returning: [Data].self) { group in\n            let semaphore = AsyncSemaphore(value: maxConcurrency)\n            var results: [Data] = Array(repeating: Data(), count: requests.count)\n            \n            for (index, request) in requests.enumerated() {\n                group.addTask {\n                    await semaphore.wait()\n                    defer { semaphore.signal() }\n                    \n                    let data = try await self.executeRequest(request)\n                    return (index, data)\n                }\n            }\n            \n            for try await (index, data) in group {\n                results[index] = data\n            }\n            \n            return results\n        }\n    }\n    \n    /// Clear cache\n    /// - Parameter olderThan: Clear entries older than specified time interval\n    func clearCache(olderThan timeInterval: TimeInterval? = nil) {\n        cacheLock.lock()\n        defer { cacheLock.unlock() }\n        \n        if let timeInterval = timeInterval {\n            let cutoffDate = Date().addingTimeInterval(-timeInterval)\n            requestCache = requestCache.filter { $1.timestamp > cutoffDate }\n            logger.info(\"Cleared cache entries older than \\(timeInterval) seconds\")\n        } else {\n            let count = requestCache.count\n            requestCache.removeAll()\n            logger.info(\"Cleared all \\(count) cache entries\")\n        }\n    }\n    \n    // MARK: - Private Methods\n    \n    private func setupNetworkMonitoring() {\n        networkMonitor.pathUpdateHandler = { [weak self] path in\n            DispatchQueue.main.async {\n                self?.updateNetworkStatus(path)\n            }\n        }\n        \n        let queue = DispatchQueue(label: \"NetworkMonitor\")\n        networkMonitor.start(queue: queue)\n    }\n    \n    private func updateNetworkStatus(_ path: NWPath) {\n        switch path.status {\n        case .satisfied:\n            if path.isExpensive {\n                networkStatus = .cellular\n            } else {\n                networkStatus = .wifi\n            }\n            isLowDataMode = path.isConstrained\n        case .unsatisfied:\n            networkStatus = .none\n        case .requiresConnection:\n            networkStatus = .unknown\n        @unknown default:\n            networkStatus = .unknown\n        }\n        \n        logger.debug(\"Network status updated: \\(networkStatus), low data mode: \\(isLowDataMode)\")\n    }\n    \n    private func executeNetworkRequest(\n        _ request: URLRequest,\n        priority: RequestPriority\n    ) async throws -> Data {\n        \n        performanceMonitor.startTimer(for: \"Network Request: \\(request.url?.absoluteString ?? \"unknown\")\")\n        defer { performanceMonitor.endTimer(for: \"Network Request: \\(request.url?.absoluteString ?? \"unknown\")\") }\n        \n        // Optimize request based on network conditions\n        var optimizedRequest = request\n        optimizedRequest = applyNetworkOptimizations(to: optimizedRequest)\n        \n        // Configure session based on priority\n        let session = urlSession(for: priority)\n        \n        do {\n            let (data, response) = try await session.data(for: optimizedRequest)\n            \n            guard let httpResponse = response as? HTTPURLResponse else {\n                throw NetworkError.invalidResponse\n            }\n            \n            guard 200...299 ~= httpResponse.statusCode else {\n                throw NetworkError.httpError(httpResponse.statusCode)\n            }\n            \n            logger.debug(\"Network request successful: \\(httpResponse.statusCode), size: \\(data.count) bytes\")\n            \n            return data\n            \n        } catch {\n            logger.error(\"Network request failed: \\(error.localizedDescription)\")\n            throw error\n        }\n    }\n    \n    private func applyNetworkOptimizations(to request: URLRequest) -> URLRequest {\n        var optimizedRequest = request\n        \n        // Add compression headers\n        optimizedRequest.setValue(\"gzip, deflate\", forHTTPHeaderField: \"Accept-Encoding\")\n        \n        // Reduce timeout on cellular networks\n        if networkStatus == .cellular || isLowDataMode {\n            optimizedRequest.timeoutInterval = Config.requestTimeout / 2\n        } else {\n            optimizedRequest.timeoutInterval = Config.requestTimeout\n        }\n        \n        // Add cache control headers\n        if isLowDataMode {\n            optimizedRequest.setValue(\"max-age=300\", forHTTPHeaderField: \"Cache-Control\")\n        }\n        \n        return optimizedRequest\n    }\n    \n    private func urlSession(for priority: RequestPriority) -> URLSession {\n        let config = URLSessionConfiguration.default\n        \n        switch priority {\n        case .high:\n            config.timeoutIntervalForRequest = 10\n            config.timeoutIntervalForResource = 30\n        case .normal:\n            config.timeoutIntervalForRequest = Config.requestTimeout\n            config.timeoutIntervalForResource = Config.requestTimeout * 2\n        case .low:\n            config.timeoutIntervalForRequest = Config.requestTimeout * 2\n            config.timeoutIntervalForResource = Config.requestTimeout * 4\n        }\n        \n        // Enable compression\n        config.httpShouldSetCookies = false\n        config.requestCachePolicy = .reloadIgnoringLocalCacheData\n        \n        return URLSession(configuration: config)\n    }\n    \n    private func createRequestKey(from request: URLRequest) -> String {\n        var components: [String] = []\n        \n        if let url = request.url {\n            components.append(url.absoluteString)\n        }\n        \n        if let method = request.httpMethod {\n            components.append(method)\n        }\n        \n        if let body = request.httpBody {\n            components.append(body.sha256)\n        }\n        \n        return components.joined(separator: \"|\").sha256\n    }\n    \n    private func getCachedResponse(for key: String, policy: CachePolicy) -> Data? {\n        cacheLock.lock()\n        defer { cacheLock.unlock() }\n        \n        guard policy != .reloadIgnoringCache,\n              let cached = requestCache[key] else {\n            return nil\n        }\n        \n        let age = Date().timeIntervalSince(cached.timestamp)\n        let maxAge = policy == .aggressive ? Config.cacheExpirationTime * 3 : Config.cacheExpirationTime\n        \n        if age > maxAge {\n            requestCache.removeValue(forKey: key)\n            return nil\n        }\n        \n        return cached.data\n    }\n    \n    private func cacheResponse(data: Data, for key: String, policy: CachePolicy) {\n        guard policy != .noCache else { return }\n        \n        cacheLock.lock()\n        defer { cacheLock.unlock() }\n        \n        requestCache[key] = CachedResponse(data: data, timestamp: Date())\n        \n        // Prevent cache from growing too large\n        if requestCache.count > 100 {\n            cleanupOldestCacheEntries()\n        }\n    }\n    \n    private func cleanupOldestCacheEntries() {\n        let sortedEntries = requestCache.sorted { $0.value.timestamp < $1.value.timestamp }\n        let entriesToRemove = sortedEntries.prefix(20)\n        \n        for (key, _) in entriesToRemove {\n            requestCache.removeValue(forKey: key)\n        }\n    }\n    \n    private func scheduleBatchProcessing() {\n        batchTimer?.invalidate()\n        batchTimer = Timer.scheduledTimer(withTimeInterval: Config.batchDelay, repeats: false) { [weak self] _ in\n            self?.processBatchQueue()\n        }\n    }\n    \n    private func processBatchQueue() {\n        batchLock.lock()\n        let requests = batchQueue\n        batchQueue.removeAll()\n        batchLock.unlock()\n        \n        guard !requests.isEmpty else { return }\n        \n        logger.info(\"Processing batch of \\(requests.count) requests\")\n        \n        Task {\n            await withTaskGroup(of: Void.self) { group in\n                for batchRequest in requests {\n                    group.addTask {\n                        do {\n                            let data = try await self.executeRequest(batchRequest.request)\n                            batchRequest.completion(.success(data))\n                        } catch {\n                            batchRequest.completion(.failure(error))\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    private func cleanup() {\n        networkMonitor.cancel()\n        batchTimer?.invalidate()\n        \n        activeRequestsLock.lock()\n        for task in activeRequests.values {\n            task.cancel()\n        }\n        activeRequests.removeAll()\n        activeRequestsLock.unlock()\n    }\n}\n\n// MARK: - Supporting Types\n\nstruct CachedResponse {\n    let data: Data\n    let timestamp: Date\n}\n\nstruct BatchRequest {\n    let request: URLRequest\n    let responseType: Any.Type\n    let completion: (Result<Data, Error>) -> Void\n}\n\nenum NetworkStatus {\n    case wifi\n    case cellular\n    case none\n    case unknown\n}\n\nenum RequestPriority {\n    case high\n    case normal\n    case low\n}\n\nenum CachePolicy {\n    case `default`      // Use cache for 5 minutes\n    case aggressive     // Use cache for 15 minutes\n    case noCache        // Never cache\n    case reloadIgnoringCache // Always reload\n}\n\nenum NetworkError: Error, LocalizedError {\n    case invalidResponse\n    case httpError(Int)\n    case noConnection\n    \n    var errorDescription: String? {\n        switch self {\n        case .invalidResponse:\n            return \"無効なレスポンスです\"\n        case .httpError(let code):\n            return \"HTTPエラー: \\(code)\"\n        case .noConnection:\n            return \"ネットワークに接続できません\"\n        }\n    }\n}\n\n// MARK: - Data Extensions\n\nextension Data {\n    var sha256: String {\n        let hash = SHA256.hash(data: self)\n        return hash.compactMap { String(format: \"%02x\", $0) }.joined()\n    }\n}\n\nextension String {\n    var sha256: String {\n        guard let data = self.data(using: .utf8) else { return \"\" }\n        return data.sha256\n    }\n}\n\n// MARK: - SHA256 Implementation\n\nimport CryptoKit\n\n// MARK: - AsyncSemaphore (if not already defined)\n\nactor AsyncSemaphore {\n    private var value: Int\n    private var waiters: [CheckedContinuation<Void, Never>] = []\n    \n    init(value: Int) {\n        self.value = value\n    }\n    \n    func wait() async {\n        if value > 0 {\n            value -= 1\n            return\n        }\n        \n        await withCheckedContinuation { continuation in\n            waiters.append(continuation)\n        }\n    }\n    \n    func signal() {\n        if waiters.isEmpty {\n            value += 1\n        } else {\n            let waiter = waiters.removeFirst()\n            waiter.resume()\n        }\n    }\n}