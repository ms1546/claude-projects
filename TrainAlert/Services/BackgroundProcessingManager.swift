//\n//  BackgroundProcessingManager.swift\n//  TrainAlert\n//\n//  Created by Claude on 2024/01/08.\n//\n\nimport Foundation\nimport OSLog\nimport Combine\n\n/// Manages background processing to optimize main thread performance\n/// Handles heavy operations that could block the UI\nfinal class BackgroundProcessingManager {\n    \n    // MARK: - Singleton\n    \n    static let shared = BackgroundProcessingManager()\n    \n    // MARK: - Properties\n    \n    private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? \"TrainAlert\", category: \"BackgroundProcessing\")\n    private let performanceMonitor = PerformanceMonitor.shared\n    \n    // Quality of Service queues for different types of operations\n    private let highPriorityQueue = DispatchQueue(label: \"com.trainalert.background.high\", qos: .userInitiated, attributes: .concurrent)\n    private let normalPriorityQueue = DispatchQueue(label: \"com.trainalert.background.normal\", qos: .utility, attributes: .concurrent)\n    private let lowPriorityQueue = DispatchQueue(label: \"com.trainalert.background.low\", qos: .background, attributes: .concurrent)\n    \n    // Operation tracking\n    private var activeOperations: [String: Task<Any, Error>] = [:]\n    private let operationsLock = NSLock()\n    \n    // MARK: - Initialization\n    \n    private init() {\n        logger.info(\"BackgroundProcessingManager initialized\")\n    }\n    \n    // MARK: - High Priority Operations\n    \n    /// Execute high priority operation that affects user experience\n    /// - Parameters:\n    ///   - operation: The operation to execute\n    ///   - operationId: Unique identifier for the operation\n    /// - Returns: Result of the operation\n    func executeHighPriority<T>(\n        operationId: String = UUID().uuidString,\n        operation: @escaping () async throws -> T\n    ) async throws -> T {\n        return try await executeOperation(\n            operationId: operationId,\n            queue: highPriorityQueue,\n            priority: \"High\",\n            operation: operation\n        )\n    }\n    \n    // MARK: - Normal Priority Operations\n    \n    /// Execute normal priority operation for general background work\n    /// - Parameters:\n    ///   - operation: The operation to execute\n    ///   - operationId: Unique identifier for the operation\n    /// - Returns: Result of the operation\n    func executeNormalPriority<T>(\n        operationId: String = UUID().uuidString,\n        operation: @escaping () async throws -> T\n    ) async throws -> T {\n        return try await executeOperation(\n            operationId: operationId,\n            queue: normalPriorityQueue,\n            priority: \"Normal\",\n            operation: operation\n        )\n    }\n    \n    // MARK: - Low Priority Operations\n    \n    /// Execute low priority operation for maintenance and cleanup tasks\n    /// - Parameters:\n    ///   - operation: The operation to execute\n    ///   - operationId: Unique identifier for the operation\n    /// - Returns: Result of the operation\n    func executeLowPriority<T>(\n        operationId: String = UUID().uuidString,\n        operation: @escaping () async throws -> T\n    ) async throws -> T {\n        return try await executeOperation(\n            operationId: operationId,\n            queue: lowPriorityQueue,\n            priority: \"Low\",\n            operation: operation\n        )\n    }\n    \n    // MARK: - Batch Operations\n    \n    /// Execute multiple operations in parallel with specified priority\n    /// - Parameters:\n    ///   - operations: Array of operations to execute\n    ///   - priority: Priority level for execution\n    ///   - maxConcurrent: Maximum number of concurrent operations\n    /// - Returns: Array of results\n    func executeBatch<T>(\n        operations: [() async throws -> T],\n        priority: ProcessingPriority = .normal,\n        maxConcurrent: Int = 4\n    ) async throws -> [T] {\n        let operationId = \"batch-\\(UUID().uuidString)\"\n        performanceMonitor.startTimer(for: \"Batch Operation: \\(operationId)\")\n        \n        let queue = queueForPriority(priority)\n        \n        let results = try await withThrowingTaskGroup(of: (Int, T).self, returning: [T].self) { group in\n            let semaphore = AsyncSemaphore(value: maxConcurrent)\n            var results: [T] = Array(repeating: nil as! T, count: operations.count)\n            \n            for (index, operation) in operations.enumerated() {\n                group.addTask {\n                    await semaphore.wait()\n                    defer { semaphore.signal() }\n                    \n                    let result = try await withCheckedThrowingContinuation { continuation in\n                        queue.async {\n                            Task {\n                                do {\n                                    let value = try await operation()\n                                    continuation.resume(returning: value)\n                                } catch {\n                                    continuation.resume(throwing: error)\n                                }\n                            }\n                        }\n                    }\n                    return (index, result)\n                }\n            }\n            \n            for try await (index, result) in group {\n                results[index] = result\n            }\n            \n            return results\n        }\n        \n        performanceMonitor.endTimer(for: \"Batch Operation: \\(operationId)\")\n        logger.info(\"Batch operation completed: \\(operations.count) operations\")\n        \n        return results\n    }\n    \n    // MARK: - Specialized Operations\n    \n    /// Process data transformation operations\n    /// - Parameters:\n    ///   - data: Input data array\n    ///   - transform: Transformation function\n    ///   - batchSize: Size of batches to process\n    /// - Returns: Transformed data array\n    func processDataTransformation<Input, Output>(\n        data: [Input],\n        transform: @escaping (Input) async throws -> Output,\n        batchSize: Int = 50\n    ) async throws -> [Output] {\n        let operationId = \"data-transform-\\(UUID().uuidString)\"\n        performanceMonitor.startTimer(for: \"Data Transformation: \\(operationId)\")\n        \n        var results: [Output] = []\n        results.reserveCapacity(data.count)\n        \n        // Process in batches to avoid memory pressure\n        for batch in data.chunked(into: batchSize) {\n            let batchResults = try await executeBatch(\n                operations: batch.map { item in\n                    { try await transform(item) }\n                },\n                priority: .normal,\n                maxConcurrent: 4\n            )\n            results.append(contentsOf: batchResults)\n        }\n        \n        performanceMonitor.endTimer(for: \"Data Transformation: \\(operationId)\")\n        logger.info(\"Data transformation completed: \\(data.count) items processed\")\n        \n        return results\n    }\n    \n    /// Execute heavy computation with progress tracking\n    /// - Parameters:\n    ///   - computation: The computation to execute\n    ///   - progressHandler: Progress callback (called on main queue)\n    /// - Returns: Result of computation\n    func executeHeavyComputation<T>(\n        computation: @escaping (@escaping (Double) -> Void) async throws -> T,\n        progressHandler: @escaping (Double) -> Void = { _ in }\n    ) async throws -> T {\n        let operationId = \"heavy-computation-\\(UUID().uuidString)\"\n        performanceMonitor.startTimer(for: \"Heavy Computation: \\(operationId)\")\n        \n        let result = try await executeNormalPriority(operationId: operationId) {\n            try await computation { progress in\n                Task { @MainActor in\n                    progressHandler(progress)\n                }\n            }\n        }\n        \n        performanceMonitor.endTimer(for: \"Heavy Computation: \\(operationId)\")\n        return result\n    }\n    \n    // MARK: - Operation Management\n    \n    /// Cancel operation by ID\n    /// - Parameter operationId: The operation ID to cancel\n    func cancelOperation(_ operationId: String) {\n        operationsLock.lock()\n        defer { operationsLock.unlock() }\n        \n        if let task = activeOperations.removeValue(forKey: operationId) {\n            task.cancel()\n            logger.info(\"Cancelled operation: \\(operationId)\")\n        }\n    }\n    \n    /// Cancel all active operations\n    func cancelAllOperations() {\n        operationsLock.lock()\n        defer { operationsLock.unlock() }\n        \n        for (operationId, task) in activeOperations {\n            task.cancel()\n            logger.debug(\"Cancelled operation: \\(operationId)\")\n        }\n        \n        activeOperations.removeAll()\n        logger.info(\"Cancelled all active operations\")\n    }\n    \n    /// Get count of active operations\n    func getActiveOperationCount() -> Int {\n        operationsLock.lock()\n        defer { operationsLock.unlock() }\n        return activeOperations.count\n    }\n    \n    // MARK: - Private Methods\n    \n    private func executeOperation<T>(\n        operationId: String,\n        queue: DispatchQueue,\n        priority: String,\n        operation: @escaping () async throws -> T\n    ) async throws -> T {\n        performanceMonitor.startTimer(for: \"\\(priority) Priority Operation: \\(operationId)\")\n        \n        // Create task and track it\n        let task = Task<T, Error> {\n            try await withCheckedThrowingContinuation { continuation in\n                queue.async {\n                    Task {\n                        do {\n                            let result = try await operation()\n                            continuation.resume(returning: result)\n                        } catch {\n                            continuation.resume(throwing: error)\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Track active operation\n        operationsLock.lock()\n        activeOperations[operationId] = task as! Task<Any, Error>\n        operationsLock.unlock()\n        \n        defer {\n            // Remove from tracking\n            operationsLock.lock()\n            activeOperations.removeValue(forKey: operationId)\n            operationsLock.unlock()\n            \n            performanceMonitor.endTimer(for: \"\\(priority) Priority Operation: \\(operationId)\")\n        }\n        \n        logger.debug(\"Started \\(priority.lowercased()) priority operation: \\(operationId)\")\n        \n        do {\n            let result = try await task.value\n            logger.debug(\"Completed \\(priority.lowercased()) priority operation: \\(operationId)\")\n            return result\n        } catch {\n            if error is CancellationError {\n                logger.info(\"Cancelled \\(priority.lowercased()) priority operation: \\(operationId)\")\n            } else {\n                logger.error(\"Failed \\(priority.lowercased()) priority operation: \\(operationId) - \\(error.localizedDescription)\")\n            }\n            throw error\n        }\n    }\n    \n    private func queueForPriority(_ priority: ProcessingPriority) -> DispatchQueue {\n        switch priority {\n        case .high:\n            return highPriorityQueue\n        case .normal:\n            return normalPriorityQueue\n        case .low:\n            return lowPriorityQueue\n        }\n    }\n}\n\n// MARK: - Supporting Types\n\nenum ProcessingPriority {\n    case high    // User-initiated operations\n    case normal  // Utility operations\n    case low     // Background maintenance\n}\n\n// MARK: - AsyncSemaphore\n\n/// Simple async semaphore implementation for controlling concurrency\nactor AsyncSemaphore {\n    private var value: Int\n    private var waiters: [CheckedContinuation<Void, Never>] = []\n    \n    init(value: Int) {\n        self.value = value\n    }\n    \n    func wait() async {\n        if value > 0 {\n            value -= 1\n            return\n        }\n        \n        await withCheckedContinuation { continuation in\n            waiters.append(continuation)\n        }\n    }\n    \n    func signal() {\n        if waiters.isEmpty {\n            value += 1\n        } else {\n            let waiter = waiters.removeFirst()\n            waiter.resume()\n        }\n    }\n}\n\n// MARK: - Array Extension\n\nprivate extension Array {\n    func chunked(into size: Int) -> [[Element]] {\n        return stride(from: 0, to: count, by: size).map {\n            Array(self[$0..<Swift.min($0 + size, count)])\n        }\n    }\n}